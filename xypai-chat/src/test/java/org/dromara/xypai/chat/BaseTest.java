package org.dromara.xypai.chat;

import org.dromara.chat.domain.entity.Conversation;
import org.dromara.chat.domain.entity.Message;
import org.dromara.chat.mapper.ConversationMapper;
import org.dromara.chat.mapper.MessageMapper;
import org.junit.jupiter.api.BeforeEach;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Base Test Class - Provides common test utilities and configuration
 *
 * Features:
 * - Spring Boot Test Configuration
 * - MockMvc for API testing
 * - Test data generation utilities
 * - Transaction rollback after each test
 * - Redis cleanup
 *
 * Usage: Extend this class for all test classes
 *
 * @author XiangYuPai Backend Team
 * @since 2025-01-14
 */
@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
@Transactional  // Rollback after each test
public abstract class BaseTest {

    @Autowired
    protected MockMvc mockMvc;

    @Autowired
    protected ConversationMapper conversationMapper;

    @Autowired
    protected MessageMapper messageMapper;

    @Autowired
    protected RedisTemplate<String, Object> redisTemplate;

    // Test user IDs
    protected static final Long TEST_USER_1 = 1L;
    protected static final Long TEST_USER_2 = 2L;
    protected static final Long TEST_USER_3 = 3L;

    // Test tokens (should be generated by auth service in real scenario)
    protected static final String TEST_TOKEN_USER_1 = "Bearer test_token_user_1";
    protected static final String TEST_TOKEN_USER_2 = "Bearer test_token_user_2";
    protected static final String TEST_TOKEN_USER_3 = "Bearer test_token_user_3";

    /**
     * Setup method - runs before each test
     */
    @BeforeEach
    public void setUp() {
        // Clear Redis cache before each test
        clearRedisCache();

        // Clean up test data
        cleanTestData();
    }

    /**
     * Clear Redis cache
     */
    protected void clearRedisCache() {
        // Clear unread count cache
        redisTemplate.delete("unread_count:" + TEST_USER_1);
        redisTemplate.delete("unread_count:" + TEST_USER_2);
        redisTemplate.delete("unread_count:" + TEST_USER_3);

        // Clear conversation list cache
        redisTemplate.delete("conversation_list:" + TEST_USER_1 + ":1");
        redisTemplate.delete("conversation_list:" + TEST_USER_2 + ":1");

        // Clear online status
        redisTemplate.delete("user:online:" + TEST_USER_1);
        redisTemplate.delete("user:online:" + TEST_USER_2);
        redisTemplate.delete("user:online:" + TEST_USER_3);
    }

    /**
     * Clean test data from database
     */
    protected void cleanTestData() {
        // This will be handled by @Transactional rollback
        // But we can add explicit cleanup if needed for specific scenarios
    }

    /**
     * Create test conversation
     */
    protected Conversation createTestConversation(Long userId, Long otherUserId) {
        Conversation conversation = Conversation.builder()
            .userId(userId)
            .otherUserId(otherUserId)
            .lastMessage("Test message")
            .lastMessageTime(LocalDateTime.now())
            .unreadCount(0)
            .deleted(0)
            .build();
        conversationMapper.insert(conversation);
        return conversation;
    }

    /**
     * Create test message
     */
    protected Message createTestMessage(Long conversationId, Long senderId, Long receiverId, String messageType, String content) {
        Message message = Message.builder()
            .conversationId(conversationId)
            .senderId(senderId)
            .receiverId(receiverId)
            .messageType(messageType)
            .content(content)
            .status(1) // Delivered
            .isRecalled(false)
            .deleted(0)
            .build();
        messageMapper.insert(message);
        return message;
    }

    /**
     * Create multiple test messages
     */
    protected List<Message> createTestMessages(Long conversationId, Long senderId, Long receiverId, int count) {
        List<Message> messages = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            Message message = createTestMessage(
                conversationId,
                senderId,
                receiverId,
                "text",
                "Test message " + (i + 1)
            );
            messages.add(message);
        }
        return messages;
    }

    /**
     * Create test conversation with messages
     */
    protected ConversationTestData createConversationWithMessages(Long userId, Long otherUserId, int messageCount) {
        // Create bidirectional conversations
        Conversation conv1 = createTestConversation(userId, otherUserId);
        Conversation conv2 = createTestConversation(otherUserId, userId);

        // Create messages
        List<Message> messages = createTestMessages(conv1.getId(), userId, otherUserId, messageCount);

        return new ConversationTestData(conv1, conv2, messages);
    }

    /**
     * Set user online status in Redis
     */
    protected void setUserOnline(Long userId, boolean isOnline) {
        String key = "user:online:" + userId;
        if (isOnline) {
            redisTemplate.opsForValue().set(key, "1");
        } else {
            redisTemplate.delete(key);
        }
    }

    /**
     * Helper class to hold conversation test data
     */
    protected static class ConversationTestData {
        public final Conversation userConversation;
        public final Conversation otherUserConversation;
        public final List<Message> messages;

        public ConversationTestData(Conversation userConversation, Conversation otherUserConversation, List<Message> messages) {
            this.userConversation = userConversation;
            this.otherUserConversation = otherUserConversation;
            this.messages = messages;
        }
    }

    /**
     * Assert that response follows R<T> wrapper format
     */
    protected void assertRFormat(String jsonResponse) {
        org.junit.jupiter.api.Assertions.assertTrue(
            jsonResponse.contains("\"code\"") &&
            jsonResponse.contains("\"message\"") &&
            jsonResponse.contains("\"data\""),
            "Response should follow R<T> format with code, message, and data fields"
        );
    }

    /**
     * Get authorization header for test user
     */
    protected String getAuthHeader(Long userId) {
        if (userId.equals(TEST_USER_1)) {
            return TEST_TOKEN_USER_1;
        } else if (userId.equals(TEST_USER_2)) {
            return TEST_TOKEN_USER_2;
        } else if (userId.equals(TEST_USER_3)) {
            return TEST_TOKEN_USER_3;
        }
        return TEST_TOKEN_USER_1;
    }
}
